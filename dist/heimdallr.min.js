/*! heimdallr v0.0.9 2016-01-29 */
!function () {
  "use strict";
  var a = angular.module("HeimdallrService", []);
  a.service("HeimdallrService", ["$http", "$rootScope", "$interval", "$log", function (a, b, c, d) {
    var e = {
      measureMissing: "HeimdallrSvc: One of the measure marks is missing: ",
      noUiRouter: "HeimdallrSvc: ui.router not in use",
      duplicateRum: "HeimdallrSvc: Property not added, duplicate key exists on rum object",
      urlMissing: "HeimdallrSvc: URL not specified stats will not be sent",
      testCount: "test count is less than entry count"
    }, f = this, g = function () {
      return (65536 * (1 + Math.random()) | 0).toString(16).substring(1)
    };
    f.append = function (a, b) {
      f.rum.customProperties[a] = b
    }, f.appendAndSend = function (a, b, c) {
      f.append(a, b);
      var d = function () {
        delete f.rum.customProperties[a]
      };
      f.sendStats(c ? d : null)
    }, f.sendStats = function (b) {
      if (angular.isDefined(f.url)) {
        f.updateRum();
        var c = a.post(f.url, f.rum, performance.clearMarks("Start:" + f.url));
        c.then(b)["finally"](function () {
          performance.clearMeasures(), performance.clearResourceTimings()
        })
      }
    }, f.rum = {
      time: new Date(Date.now()),
      location: {href: window.location.href, hash: window.location.hash, hostname: window.location.hostname},
      angularVersion: angular.version,
      userAgent: navigator.userAgent,
      watcherCount: b.$$watchersCount,
      guid: null,
      customProperties: {},
      navigation: performance.timing,
      resources: performance.getEntriesByType("resource"),
      marks: performance.getEntriesByType("mark"),
      measures: performance.getEntriesByType("measure"),
      memory: {
        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
        totalJSHeapSize: performance.memory.totalJSHeapSize,
        usedJSHeapSize: performance.memory.usedJSHeapSize
      }
    }, f.interval = 1e4, f.routeEventArray = [], f.customEventArray = [], f.addEvent = function (a) {
      performance.mark(a), f.customEventArray.push(a)
    }, f.updateRum = function () {
      f.rum.time = new Date(Date.now()), f.watcherCount = b.$$watchersCount, f.navigation = performance.timing, f.resources = performance.getEntriesByType("resource"), f.marks = performance.getEntriesByType("mark"), f.measures = performance.getEntriesByType("measure"), f.memory = {
        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
        totalJSHeapSize: performance.memory.totalJSHeapSize,
        usedJSHeapSize: performance.memory.usedJSHeapSize
      }, f.routeEventArray.length > 0 && (f.rum.routeEvents = f.routeEventArray)
    }, f.measure = function (a, b, c, g) {
      try {
        performance.measure(a, b, c), g === !0 && f.customEventArray.splice(f.customEventArray.indexOf(b, 1)).splice(f.customEventArray.indexOf(c, 1))
      } catch (h) {
        d.debug(e.measureMissing + h)
      }
    }, f.performanceTest = function (a) {
      var b = 0, c = 0, g = window.location.host, h = window.location.protocol;
      performance.getEntries().length > a ? b = a : (d.debug(e.testCount), b = performance.getEntries().length);
      for (var i = 0; b > i; i++) {
        var j = performance.getEntries()[i], k = j.name, l = document.createElement("a");
        if (l.href = j.name, l.host == g && l.protocol == h) {
          var m = new XMLHttpRequest;
          if (m.open("HEAD", k, !1), m.send(null), 200 === m.status) {
            var n = parseInt(m.getResponseHeader("content-length"));
            if (n > 1024) {
              var o = n / 1024;
              c += o / 1024 / (j.duration / 1e3 / 1e3)
            }
          }
        }
      }
      f.rum.downloadSpeed = Math.round(c / b), f.rum.downloadSpeedUnit = "mb/s"
    }, f.init = function (a) {
      if (a.debug && d.debugEnabled(!0), angular.isDefined(a.guid) ? f.rum.guid = a.guid : f.rum.guid = (g() + g() + "-" + g() + "-4" + g().substr(0, 3) + "-" + g() + "-" + g() + g() + g()).toLowerCase(), angular.isDefined(a.customProperties)) {
        var b = a.customProperties;
        for (var c in b)b.hasOwnProperty(c) && (f.rum.hasOwnProperty(c) ? d.debug(e.duplicateRum) : f.rum[c] = b[c])
      }
      angular.isUndefined(a.url) ? d.debug(e.urlMissing) : f.url = a.url, angular.isDefined(a.interval) && (f.interval = a.interval)
    }, f.bindRoutingEvents = function () {
      try {
        angular.isDefined(angular.module("ui.router")) && (b.$on("$stateChangeStart", function (a, b, c, d, e) {
          var g = new Date(Date.now()).getTime();
          f.routeEventArray.push({event: g, fromState: d, fromParams: e, toState: b, toParams: c}), performance.mark(g)
        }), b.$on("$viewContentLoaded", function () {
          var a = new Date(Date.now()).getTime();
          if (performance.mark(a), f.routeEventArray.length > 1) {
            var b = f.routeEventArray[f.routeEventArray.length - 1].toState.name, c = f.routeEventArray[f.routeEventArray.length - 1].fromState.name, g = f.routeEventArray[f.routeEventArray.length - 1].event;
            try {
              performance.measure("Successful change from: " + c + " to: " + b, g, a)
            } catch (h) {
              d.debug(e.measureMissing + h)
            }
            performance.clearMarks(g)
          }
          f.appendAndSend("currentView", b)
        }))
      } catch (a) {
        d.debug(e.noUiRouter)
      }
    }, c(f.sendStats, f.interval)
  }]), a.provider("Heimdallr", ["$provide", "$httpProvider", function (a, b) {
    var c = {};
    c.bindHttp = function () {
      d()
    };
    var d = function () {
      a.factory("httpInterceptor", ["$q", function (a) {
        return {
          request: function (b) {
            return performance.mark("Start:" + b.url), b || a.when(b)
          }, response: function (b) {
            try {
              performance.mark("End:" + b.config.url), performance.measure(b.config.url, "Start:" + b.config.url, "End:" + b.config.url)
            } catch (c) {
            }
            return performance.clearMarks("Start:" + b.config.url), performance.clearMarks("End:" + b.config.url), b || a.when(b)
          }, requestError: function (b) {
            try {
              performance.measure("RESPONSE ERROR: " + b.config.url, "Start:" + b.config.url, "End:" + b.config.url)
            } catch (c) {
            }
            return performance.clearMarks("Start:" + b.config.url), performance.clearMarks("End:" + b.config.url), a.reject(b)
          }, responseError: function (b) {
            try {
              performance.measure("RESPONSE ERROR: " + b.config.url, "Start:" + b.config.url, "End:" + b.config.url)
            } catch (c) {
            }
            return performance.clearMarks("Start:" + b.config.url), performance.clearMarks("End:" + b.config.url), a.reject(b)
          }
        }
      }]), b.interceptors.push("httpInterceptor")
    };
    return {
      $get: function () {
        return c
      }
    }
  }])
}();